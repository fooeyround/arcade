/*
 * Copyright (c) 2025 senseiwells
 * Licensed under the MIT License. See LICENSE file in the project root for details.
 */
package net.casual.arcade.replay.recorder.chunk

import me.senseiwells.replay.ServerReplay
import net.minecraft.resources.ResourceKey
import net.minecraft.server.MinecraftServer
import net.minecraft.server.level.ServerLevel
import net.minecraft.world.level.ChunkPos
import net.minecraft.world.level.Level
import net.minecraft.world.level.levelgen.structure.BoundingBox
import java.util.*
import java.util.concurrent.CompletableFuture
import kotlin.collections.HashMap
import kotlin.collections.LinkedHashMap

/**
 * This object manages all [ReplayChunkRecorder]s.
 */
public object ChunkRecorders {
    private val chunks = LinkedHashMap<ChunkArea, ReplayChunkRecorder>()
    private val chunksByName = LinkedHashMap<String, ReplayChunkRecorder>()
    private val closing = HashMap<String, ReplayChunkRecorder>()

    /**
     * This creates a [ReplayChunkRecorder].
     *
     * @param level The level which the recorder is in.
     * @param from The chunk corner to record from.
     * @param to The chunk corner to record to.
     * @param name The name of the recorder.
     * @return The created recorder.
     */
    @JvmStatic
    public fun create(level: ServerLevel, from: ChunkPos, to: ChunkPos, name: String): ReplayChunkRecorder {
        return create(ChunkArea(level, from, to), name)
    }

    /**
     * This creates a [ReplayChunkRecorder].
     *
     * @param area The chunk area to record.
     * @param name The name of the recorder, one will be generated by if not provided.
     * @return The created recorder.
     */
    @JvmStatic
    @JvmOverloads
    public fun create(area: ChunkArea, name: String = generateName(area)): ReplayChunkRecorder {
        if (chunks.containsKey(area)) {
            throw IllegalArgumentException("Recorder for chunk area already exists")
        }
        if (chunksByName.containsKey(name)) {
            throw IllegalArgumentException("Recorder with name already exists")
        }

        val path = ServerReplay.config.chunkRecordingPath.resolve(name)
        val recorder = ReplayChunkRecorder(
            area,
            name,
            ServerReplay.config.writerType.create(path)
        )
        chunks[area] = recorder
        chunksByName[name] = recorder
        // TODO:
//        RecorderRecoverer.add(recorder)
        return recorder
    }

    /**
     * Whether a chunk recorder with a given [name] exists.
     *
     * @param name The name to check.
     * @return Whether a chunk recorder with that name exists.
     */
    @JvmStatic
    public fun has(name: String): Boolean {
        return chunksByName.containsKey(name)
    }

    /**
     * Whether a chunk recorder for the given [area] exists.
     *
     * @param area The area to check.
     * @return Whether a chunk recorder with that area exists.
     */
    @JvmStatic
    public fun has(area: ChunkArea): Boolean {
        return chunks.containsKey(area)
    }

    /**
     * Checks whether the given [area] and [name] is available
     * or whether at least one is already taken.
     *
     * @param area The area to check.
     * @param name The name to check.
     * @return Whether the area and name are both available.
     */
    @JvmStatic
    public fun isAvailable(area: ChunkArea, name: String): Boolean {
        return !has(area) && !has(name)
    }

    /**
     * Gets a [ReplayChunkRecorder] for a given name.
     *
     * @param name The name of the recorder.
     * @return The recorder instance with the given name, null if it doesn't exist.
     */
    @JvmStatic
    public fun get(name: String): ReplayChunkRecorder? {
        return chunksByName[name]
    }

    /**
     * Gets a [ReplayChunkRecorder] for a given [area].
     *
     * @param area The area of the recorder.
     * @return The recorder instance with the given area, null if it doesn't exist.
     */
    @JvmStatic
    public fun get(area: ChunkArea): ReplayChunkRecorder? {
        return chunks[area]
    }

    /**
     * Gets all the [ReplayChunkRecorder]s that contain a given [chunk] in the given [level].
     *
     * @param level The level to check in.
     * @param chunk The position the recorder must contain.
     * @return A list of chunk recorders.
     */
    @JvmStatic
    public fun containing(level: ResourceKey<Level>, chunk: ChunkPos): List<ReplayChunkRecorder> {
        return chunks.values.filter { it.chunks.contains(level, chunk) }
    }

    /**
     * Gets all the [ReplayChunkRecorder]s that intersect a given [box] in the given [level].
     *
     * @param level The level to check in.
     * @param box The bounding box the recorder must intersect with.
     * @return A list of chunk recorders.
     */
    @JvmStatic
    public fun intersecting(level: ResourceKey<Level>, box: BoundingBox): List<ReplayChunkRecorder> {
        return chunks.values.filter { it.chunks.intersects(level, box) }
    }

    /**
     * Gets a collection of all the currently recording chunk recorders.
     *
     * @return A collection of all the chunk recorders.
     */
    @JvmStatic
    public fun recorders(): Collection<ReplayChunkRecorder> {
        return Collections.unmodifiableCollection(this.chunks.values)
    }

    /**
     * Gets a collection of all the currently closing chunk recorders.
     *
     * @return A collection of all the closing chunk recorders.
     */
    @JvmStatic
    public fun closing(): Collection<ReplayChunkRecorder> {
        return Collections.unmodifiableCollection(this.closing.values)
    }

    /**
     * This updates a [ReplayChunkRecordable] adding and removing chunk
     * recordings that should be recording it.
     *
     * @param recordable The recordable to update.
     * @param level The level in which the recordable should be recorded in.
     * @param chunk The chunk in which the recordable is in.
     * @see ReplayChunkRecordable
     */
    @JvmStatic
    public fun updateRecordable(
        recordable: ReplayChunkRecordable,
        level: ResourceKey<Level>,
        chunk: ChunkPos
    ) {
        updateRecordable(recordable) { it.contains(level, chunk) }
    }

    /**
     * This updates a [ReplayChunkRecordable] adding and removing chunk
     * recordings that should be recording it.
     *
     * @param recordable The recordable to update.
     * @param level The level in which the recordable should be recorded in.
     * @param box The bounding box of the recordable.
     * @see ReplayChunkRecordable
     */
    @JvmStatic
    public fun updateRecordable(
        recordable: ReplayChunkRecordable,
        level: ResourceKey<Level>,
        box: BoundingBox
    ) {
        updateRecordable(recordable) { it.intersects(level, box) }
    }

    /**
     * This generates a name for a given [area].
     *
     * @param area The chunk area.
     * @return The name for the given [area].
     */
    public fun generateName(area: ChunkArea): String {
        return "Chunks (${area.from.x}, ${area.from.z}) to (${area.to.x}, ${area.to.z})"
    }

    internal fun remove(area: ChunkArea): ReplayChunkRecorder? {
        val recorder = chunks.remove(area)
        if (recorder != null) {
            chunksByName.remove(recorder.getName())
        }
        return recorder
    }

    internal fun close(
        server: MinecraftServer,
        recorder: ReplayChunkRecorder,
        future: CompletableFuture<Long>
    ) {
        this.remove(recorder.chunks)
        this.closing[recorder.recorderName] = recorder
        future.thenRunAsync({
            this.closing.remove(recorder.recorderName)
        }, server)
    }

    private fun updateRecordable(
        recordable: ReplayChunkRecordable,
        predicate: (ChunkArea) -> Boolean
    ) {
        val existing = recordable.getRecorders()
        for (recorder in chunks.values) {
            if (predicate(recorder.chunks)) {
                if (!existing.contains(recorder)) {
                    recordable.addRecorder(recorder)
                }
            } else if (existing.contains(recorder)) {
                recordable.removeRecorder(recorder)
            }
        }
    }
}