/*
 * Copyright (c) 2025 senseiwells
 * Licensed under the MIT License. See LICENSE file in the project root for details.
 */
package net.casual.arcade.replay.recorder.chunk

import it.unimi.dsi.fastutil.objects.Object2ReferenceOpenHashMap
import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet
import net.casual.arcade.events.GlobalEventHandler
import net.casual.arcade.events.ListenerRegistry.Companion.register
import net.casual.arcade.events.server.ServerStopEvent
import net.casual.arcade.events.server.ServerTickEvent
import net.casual.arcade.replay.io.ReplayFormat
import net.casual.arcade.replay.recorder.settings.RecorderSettings
import net.casual.arcade.replay.recorder.settings.SimpleRecorderSettings
import net.minecraft.network.protocol.Packet
import net.minecraft.resources.ResourceKey
import net.minecraft.server.MinecraftServer
import net.minecraft.world.level.ChunkPos
import net.minecraft.world.level.Level
import net.minecraft.world.level.levelgen.structure.BoundingBox
import java.nio.file.Path
import java.util.*
import java.util.concurrent.CompletableFuture

/**
 * This object manages all [ReplayChunkRecorder]s.
 */
public object ReplayChunkRecorders {
    private val recorders = Object2ReferenceOpenHashMap<String, ReplayChunkRecorder>()
    private val closing = ObjectOpenHashSet<ReplayChunkRecorder>()

    /**
     * This creates a [ReplayChunkRecorder].
     *
     * @param area The chunk area to record.
     * @param directory The directory to write the recorded replay to.
     * @param settings The recorder settings to use.
     * @param name The name of the recorder, one will be generated by if not provided.
     * @return The created recorder.
     */
    @JvmStatic
    @JvmOverloads
    public fun create(
        area: ChunkArea,
        directory: Path,
        format: ReplayFormat = ReplayFormat.ReplayMod,
        settings: RecorderSettings = SimpleRecorderSettings.DEFAULT,
        name: String = this.createNameFor(area),
    ): ReplayChunkRecorder {
        if (this.has(name)) {
            throw IllegalArgumentException("ReplayChunkRecorder with name '${name}' already exists")
        }

        val recorder = ReplayChunkRecorder(area, name, settings, format, directory)
        this.recorders[name] = recorder
        return recorder
    }

    /**
     * Whether a chunk recorder with a given [name] exists.
     *
     * @param name The name to check.
     * @return Whether a chunk recorder with that name exists.
     */
    @JvmStatic
    public fun has(name: String): Boolean {
        return this.recorders.containsKey(name)
    }

    /**
     * Gets a [ReplayChunkRecorder] for a given name.
     *
     * @param name The name of the recorder.
     * @return The recorder instance with the given name, null if it doesn't exist.
     */
    @JvmStatic
    public fun get(name: String): ReplayChunkRecorder? {
        return this.recorders[name]
    }

    /**
     * Gets all the [ReplayChunkRecorder]s that contain a given [chunk] in the given [level].
     *
     * @param level The level to check in.
     * @param chunk The position the recorder must contain.
     * @return A list of chunk recorders.
     */
    @JvmStatic
    public fun containing(level: ResourceKey<Level>, chunk: ChunkPos): List<ReplayChunkRecorder> {
        return this.recorders.values.filter { it.chunks.contains(level, chunk) }
    }

    /**
     * Gets all the [ReplayChunkRecorder]s that intersect a given [box] in the given [level].
     *
     * @param level The level to check in.
     * @param box The bounding box the recorder must intersect with.
     * @return A list of chunk recorders.
     */
    @JvmStatic
    public fun intersecting(level: ResourceKey<Level>, box: BoundingBox): List<ReplayChunkRecorder> {
        return this.recorders.values.filter { it.chunks.intersects(level, box) }
    }

    /**
     * Gets a collection of all the currently recording chunk recorders.
     *
     * @return A collection of all the chunk recorders.
     */
    @JvmStatic
    public fun recorders(): Collection<ReplayChunkRecorder> {
        return ArrayList(this.recorders.values)
    }

    /**
     * Gets a collection of all the currently closing chunk recorders.
     *
     * @return A collection of all the closing chunk recorders.
     */
    @JvmStatic
    public fun closing(): Collection<ReplayChunkRecorder> {
        return ArrayList(this.closing)
    }

    /**
     * Records a given packet for all chunk recorders.
     *
     * @param packet The packet to record.
     */
    @JvmStatic
    public fun record(packet: Packet<*>) {
        for (recorder in this.recorders.values) {
            recorder.record(packet)
        }
    }

    /**
     * This updates a [ReplayChunkRecordable] adding and removing chunk
     * recordings that should be recording it.
     *
     * @param recordable The recordable to update.
     * @param level The level in which the recordable should be recorded in.
     * @param chunk The chunk in which the recordable is in.
     * @see ReplayChunkRecordable
     */
    @JvmStatic
    public fun updateRecordable(
        recordable: ReplayChunkRecordable,
        level: ResourceKey<Level>,
        chunk: ChunkPos
    ) {
        this.updateRecordable(recordable) { it.contains(level, chunk) }
    }

    /**
     * This updates a [ReplayChunkRecordable] adding and removing chunk
     * recordings that should be recording it.
     *
     * @param recordable The recordable to update.
     * @param level The level in which the recordable should be recorded in.
     * @param box The bounding box of the recordable.
     * @see ReplayChunkRecordable
     */
    @JvmStatic
    public fun updateRecordable(
        recordable: ReplayChunkRecordable,
        level: ResourceKey<Level>,
        box: BoundingBox
    ) {
        this.updateRecordable(recordable) { it.intersects(level, box) }
    }

    /**
     * This generates a name for a given [area].
     *
     * @param area The chunk area.
     * @return The name for the given [area].
     */
    public fun createNameFor(area: ChunkArea): String {
        return "Chunks (${area.from.x}, ${area.from.z}) to (${area.to.x}, ${area.to.z})"
    }

    internal fun registerEvents() {
        GlobalEventHandler.Server.register<ServerStopEvent>(phase = ServerStopEvent.PHASE_POST) {
            for (recorder in this.recorders.values.toList()) {
                recorder.stop()
            }
        }
        GlobalEventHandler.Server.register<ServerTickEvent> {
            for (recorder in this.recorders.values) {
                recorder.tick()
            }
        }
    }

    internal fun remove(recorder: ReplayChunkRecorder) {
        this.recorders.remove(recorder.recorderName, recorder)
    }

    internal fun close(
        server: MinecraftServer,
        recorder: ReplayChunkRecorder,
        future: CompletableFuture<Long>
    ) {
        this.remove(recorder)
        this.closing.add(recorder)
        future.thenRunAsync({
            this.closing.remove(recorder)
        }, server)
    }

    private fun updateRecordable(
        recordable: ReplayChunkRecordable,
        predicate: (ChunkArea) -> Boolean
    ) {
        val existing = recordable.getRecorders()
        for (recorder in this.recorders.values) {
            if (predicate(recorder.chunks)) {
                if (!existing.contains(recorder)) {
                    recordable.addRecorder(recorder)
                }
            } else if (existing.contains(recorder)) {
                recordable.removeRecorder(recorder)
            }
        }
    }
}